\documentclass{homework}
\author{Morales, Samantha}
\class{CSCI 2114: Tashfeen's Data Structures}
\date{\today}
\title{Homework 1}
\address{%
  Oklahoma City University, %
  Petree College of Arts \& Sciences, %
  Computer Science%
}

% \acmfonts
\newcommand\callit[1]{Store the code in a file called \texttt{#1}.}
\newcommand\docs{\href{%
    https://tinyurl.com/25w2e4wy%
  }{%
    \texttt{Byte.toUnsignedInt(byte x)}%
  }%
}

\begin{document} \maketitle

\question Briefly define the following terms in context of computer
hardware.


\begin{enumerate}
  \item Register 
    \begin{sol}
    - The fastest available memory, located in the CPU. Usually either 64bit or 32bit. Smaller available memory than RAM, but it is much faster.
    \end{sol}
  \item Memory
    \begin{sol}
      - Random Access Memory (RAM) is fast, short-term memory, it is faster than writing to the disk, but it cannot store anything.
    \end{sol}
  \item Disk
    \begin{sol}
      - The slowest memory, used for long term storage of files. 
    \end{sol}
\end{enumerate}

\question What is the smallest addressable unit of memory in most modern
computers? \\
\begin{sol}
  1 (one) Byte.
\end{sol}

\question Give the number of bytes in the following memory units as either 2
or 10 raised to an appropriate power. For example, a Kibibyte
(KiB) is $2^{10}$ bytes while a Kilobyte (KB) is $10^3$ bytes.

\begin{enumerate}
  \item Mebibyte (MiB)
    \begin{sol}
       - $2^{20}$ Bytes
    \end{sol}
  \item Megabyte (MB)
    \begin{sol}
       - $10^6$ Bytes
    \end{sol}
  \item Gibibyte (GiB)
    \begin{sol}
       - $2^{30}$ Bytes 
    \end{sol}
  \item Gigabyte (GB)
    \begin{sol}
       - $10^9$ Bytes
    \end{sol}
  \item Tebibyte (TiB)
    \begin{sol}
       - $2^{40}$ Bytes
    \end{sol}
  \item Terabyte (TB)
  \begin{sol}
     - $10^{12}$ Bytes
  \end{sol}
  \item Pebibyte (TiB)
  \begin{sol}
     - $2^{50}$ Bytes
  \end{sol}
  \item Petabyte (TB)
  \begin{sol}
     - $10^{15}$ Bytes
  \end{sol}
\end{enumerate}

Why is there a need for two byte-prefixed unit systems? \\
\begin{sol}
  For ease of communication, when we see prefixes like "kilo, mega, giga" we are thinking about powers of 10
  due to the metric system's use of these prefixes. However, computer scientists like to work with powers of 2,
  so it is also useful to have a base-2 unit system. Allowing for computer scientists and non-computer scientists to communicate with ease.
\end{sol}

\question Java class in listing \ref{types} prints the maximum numerical
value each Java primitive type can store. Explain how these are
calculated \ie their connection to register size and numerical
sign.

\lstinputlisting[
  language={java},
  caption={Java class to print maximum values of primitive types.},
  label=types]
{code/Constants.java}

\begin{sol}
  Byte, short, int, and long all have a bit dedicated to sign, so the maximum numerical value 
  they can represent is their allocated memory minus one bit. Since we start counting from 0 in computer science,
  we subtract one value from the maximum values. Thus, the max values are as follows.

  \begin{itemize}
    \item byte - $2^7-1$
    \item short - $2^{15}-1$
    \item int - $2^{31}-1$
    \item long - $2^{63}-1$
    \item char - $2^{16}-1$
    \item float - 
    \item double - 
  \end{itemize}
  
\end{sol}

\question Write a Java program that prints out one line of text to the
console. It can be anything but ``Hello World!'' What did you
print? \callit{Anything.java}

\begin{sol}
  I printed the line "UwU"
\end{sol}

\question Write a Java program that populates an array of size $n$ with the
first $n$ Fibonacci numbers. The program should print out the
array as shown in figure ??. Here $n$ should be the first
command line argument. You may do it anyway you like but one and
arguably the most elegant way to do it is recursively as shown in
the listing \ref{fib}. What is the name of the implicit call
structure that is used in listing \ref{fib}? Hint: Stack Overflow.
\callit{Fibonacci.java}


\begin{sol}
  Call stack.
\end{sol}

\lstinputlisting[
  linerange={22-26},
  language={java},
  caption={Java function to generate the Fibonacci sequence.},
  label=fib]
{code/Fibonacci.java}

\question Using the
\href{https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes}{Sieve
  of Eratosthenes}, populate a boolean array of size $n$ (Java
booleans initialise to false) marking all the indices that are
Composite numbers to true. Here $n$ should be the first command
line argument. The indices remaining false at the end should be
Prime numbers.
  \callit{Eratosthenes.java}

\begin{enumerate}
  \item For debugging, have your program print all the prime numbers less
        than a 100. You should get the following: $ 2, 3, 5, 7, 11, 13,
          17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79,
          83, 89, 97. $
  \item The program should print out at most the five largest prime
        numbers it computed and the time (seconds) it took to compute all
        the primes less than $n$. Here is a way to compute seconds taken
        by a function call \texttt{eratosthenes(toSieve)}.

        \begin{lstlisting}[language=java]
double startTime = System.nanoTime();
eratosthenes(toSieve);
double duration = System.nanoTime() - startTime;
duration = duration / Math.pow(10, 9);
\end{lstlisting}

  \item With your program, calculate how long does it take (in seconds) to
        compute all the 30 bit prime numbers. These are all primes less
        than $n = 2^{30} = 1073741824$.

  \item Can your implementation of the Sieve of Eratosthenes compute all
        the 32 bit prime numbers? If yes, give the time it takes or if it
        can not, then why not?
        \begin{sol}
          It cannot compute all 32 bit primes because int can only represent up to $2^{31}-1$.

        \end{sol}
\end{enumerate}

\question\label{32bitprimes} Read all bytes in the file
\href{https://tinyurl.com/24bvsnaf}{\texttt{half\_gaps.bin}}. You may
use the function in code listing ??.

% \lstinputlisting[
%   linerange={36-44},
%   language={java},
%   caption={Java function to read in a file's (signed) bytes.},
%   label=byte]
% {code/Primes.java}

The function in code listing ?? reads in signed bytes.
While this maybe suitable for some binary arrangements, we want
the bytes to be unsigned. One way to achieve this is to just loop
and use \docs{} as seen in listing ??.

% \lstinputlisting[
%   linerange={9-13},
%   language={java},
%   caption={Converting Java signed bytes to unsigned longs.},
%   label=long]
% {code/Primes.java}

Compute the array of integers' cumulative sum \ie
\[
  \curl{x_i \in \mathtt{cumsum}(x) : x_i = \sum_{k=1}^{i} x_k}
\]
Now multiply each of the sums with 2 and then add a 3.
\[
  \curl{x_i \in \mathtt{cumsum}(x) :
    y_i = 2x_i+3 = 2\paren{\sum_{k=1}^{i} x_k}+3}
\]
\begin{enumerate}
  \item Print out the first fifteen and the last five elements of this
        final array.
  \item Time this program (the reading of bytes, the cumulative sum
        computation and the doubling with adding a three) and print the
        result in seconds.
  \item Do you recognise the printed numbers? What wil  l these be if we
        further prepended a 2 and a 3 to them?
        \begin{sol}
          Prime numbers
        \end{sol}
\end{enumerate}

% \callit{Primes.java}

\question Accumulate the approximate probability that an integer $2 \leq x
  \leq 2^{31}-1$ is prime. You can do this by generating random
numbers between $2$ and $2^{31}-1$ within a big enough loop and
check if the number is prime (this is known as a primality test)
by searching for it in the array of prime numbers we constructed
in
question \ref{32bitprimes}.  The main loop is shown in listing
??.  You need to implement the linear search and the
binary search and uncomment each, one at a time to report the times in
seconds taken by each type of search.

% \lstinputlisting[
%   linerange={19-28},
%   language={java},
%   caption={Linear and binary search for a prime number.},
%   label=primality]
% {code/Search.java}

Does the printed number converge? \callit{Search.java}

\begin{sol}
  The following is a function that approximates the probability that any number less than N is a \href{https://en.wikipedia.org/wiki/Prime_number_theorem#:~:text=This%20means%20that%20for%20large%20enough%20N,%20the%20probability%20that%20a%20random%20integer%20not%20greater%20than%20N%20is%20prime%20is%20very%20close%20to%201%20/%20log(N).}{prime.}
  \[
    \frac{1}{ln(N)}
  \]
  when you plug in $N=2^{31}-1$ you get 
  \[
    \frac{1}{ln(2^{31}-1)}=0.0480898347
  \]
  My application converged at $\approx 0.0489750489$
  
\end{sol}

\question Break the Affine cipher. Your professor encrypted a plain text
file called \texttt{plain.txt} using the program given in listing
??. \callit{Decipher.java}

He then redirected the output to a cipher file called
\href{https://tinyurl.com/24pjud2t}{\texttt{cipher.txt}}.

\begin{enumerate}
  \item Use the cipher text file and the code in listing ?? to
        recover the plain text. \textit{Hint}: $7^{-1} = 55 \mod 2^7$.
  \item What should the $2^7$ tell you about the text encoding of the
        original plain text file?
\end{enumerate}

% \lstinputlisting[
%   language={java},
%   caption={An Affine cipher in Java.},
%   label=cipher]
% {code/Decipher.java}

\section{Example Executions}

Figure ?? shows how the output of the code for the files
\texttt{Fibonacci.java} and \texttt{Eratosthenes.java} should look
like on the standard out. All your programs must compile/run from
the command line using \texttt{javac} and \texttt{java} commands,
e. g.,

\begin{verbatim}
javac Program.java
java Program
\end{verbatim}


% \img<exmp>[0.65]
% {Example execution of the code for the first three questions.} {media/example.png}

\section{Submission Instructions}

\begin{itemize}
  \item Submit \texttt{Anything.java}, \texttt{Fibonacci.java},
        \texttt{Eratosthenes.java}, \texttt{Primes.java},
        \texttt{Search.java},

        \noindent\texttt{Decipher.java} and
        \texttt{sol.pdf} at the online classroom.

  \item The files \texttt{Anything.java}, \texttt{Fibonacci.java},
        \texttt{Eratosthenes.java}, \texttt{Primes.java},
        \texttt{Search.java},

        \noindent\texttt{Decipher.java} should contain the
        Java source code for the relevant questions. Do not turn in the dot class files.

  \item The PDF file \texttt{sol.pdf} should contain written answers to
        questions as well as a screenshot similar to the one in figure ??
        that demonstrates your code being compiled and ran.
\end{itemize}

\img<img>[0.65]{Submission Image 1}{media/SolScreenshot.png}

\img<img1>[0.65]{Submission Image 2}{media/PrimesScreenshot.png}

\img<img2>[0.65]{Submission Image 3}{media/LinearSearchScreenshot.png}

\img<img3>[0.65]{Submission Image 4}{media/BinarySearchScreenshot.png}

\img<img4>[0.65]{Submission Image 5}{media/DecipherScreenshot.png}

  






\end{document}
